---
layout: post
title:  "Using the DDL for Fun and Profit"
number: 1
---

# Running the Interactive Console {#interactive-console}

Now that we've got our environments up and running, we should get down to actually using the sqlite console. 

sqlite has the nice property of letting you to use it with a temporary database that disappears after you exit the sqlite console. 

While losing all of your data isn't normally a desirable quality in a database, it's pretty useful when you just want to start writing some SQL to experiment. 

To do this, you can launch the sqlite console by just running the command:

{% highlight shell %}
$ sqlite3
{% endhighlight %}

You should see something that looks like this:

![SQLite With Temporary Database]({{ site.baseurl }}/assets/01/sqlite-in-memory.png)

Note the warning message:

    Connected to a transient in-memory database.
    Use ".open FILENAME" to reopen on a persistent database.

Great. That means that as soon as we exit the sqlite console, everything from that session is gone.

To exit the console, type the following command:

    sqlite> .quit

In the sqlite console you can issue special commands that won't be interpreted as SQL. The commands all start with '.'. For instance `sqlite> .help` will show you a list of other available commands. If you get stuck trying to exit the console and `sqlite> .quit` doesn't seem to be working, `CTRL + D` will also work to get you out of the sqlite console.

Go ahead and try out `.quit` and you should be back out of the sqlite console

![SQLite quit]({{ site.baseurl }}/assets/01/sqlite-quit.png)

# Keeping the Database
While throwing data away is sometimes useful, it's not always what you want. To keep data around between sessions, you launch sqlite and give it a file to store the database contents in. If the file already exists, it will load with all the existing data. If the file doesn't exist yet, it'll create the file and store data in it.

Let's try creating a database with persistent data. Run the command below:

{% highlight shell %}
$ sqlite3 mammoth.db
{% endhighlight %}

You should see the familiar prompt, but this time the database will exist between sessions

![SQLite file backed database]({{ site.baseurl }}/assets/01/sqlite-filedb.png)


# Creating Tables (finally) {#creating-tables}
So we've got the basics about the sqlite console, let's actual use some DDL! The table definitions we'll use in the next lessons are in `01-basic-ddl.sql` and are as follows:

{% highlight sql %}
CREATE TABLE users (
    id integer primary key,
    email_address varchar not null,
    first_name varchar,
    last_name varchar,
    is_admin boolean not null default false
);

CREATE TABLE products (
    id integer primary key,
    name varchar not null,
    price decimal(5, 2) not null
);

CREATE TABLE orders (
    id integer primary key,
    user_id integer not null,
    placed_at timestamp not null default current_timestamp,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE order_products (
    id integer primary key,
    order_id integer not null,
    product_id integer not null,
    FOREIGN KEY (order_id) REFERENCES orders(id),
    FOREIGN KEY (product_id) REFERENCES products(id)
);
{% endhighlight %}

Those `FOREIGN KEY` declarations probably look a little weird. Those essentially enforce that values inserted into the table have corresponding values in another table. For instance, the orders table has the following constraint:

    FOREIGN KEY (user_id) REFERENCES users(id)

which means that all rows in orders must have a value for user_id that exists in the users table as id. This prevents the possibility of rows being inserted into the orders table that don't make any sense.

We could copy / paste the definitions above, but since we have the sqlite console open already, let's just tell sqlite to execute sql from the ddl file. Enter the following command to read the 01-basic-ddl.sql file:

    sqlite> .read 01-basic-ddl.sql

If you saw a blank line output into the console and nothing else, you probably did it right. Let's make sure the tables actually exist by using the sqlite `.schema` command:

    sqlite> .schema

You should see some output that looks like the following:

![Schema Output]({{ site.baseurl }}/assets/01/sqlite-schema.png)

If your output looks like above, then we're ready to [start working with some data]({{ site.baseurl }}/{% post_url 2016-03-01-02-intro-to-dml %}).

